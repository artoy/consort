\section{Inference and Extensions}
\label{sec:infr}
We now briefly describe the inference algorithm implemented in
our tool \name. We sketch some implemented extensions needed to type more
interesting programs and close with a discussion of current
limitations of our prototype.

\subsection{Inference}
Our tool first runs a standard, simple type inference
algorithm to generate type templates for every function parameter
type, return type, and for every live variable at each program point.
For a variable $x$ of simple type $\tau_{S} ::=  \TINT  \mid  \tau_{S}  \TREF $
at program point $p$, \name generates a type template $ \sem{ \tau_{S} }_{ \mathit{x} , \ottsym{0} , p } $
as follows:
\begin{align*}
   \sem{  \TINT  }_{ \mathit{x} , n , p }  =  \set{  \nu  \COL \TINT \mid    \varphi _{ \mathit{x} , n , p }  ( \nu ;   \ottkw{FV} _{ p }  )  }  &&  \sem{  \tau_{S}  \TREF  }_{ \mathit{x} , n , p }  =   \sem{ \tau_{S} }_{ \mathit{x} , n  \ottsym{+}  \ottsym{1} , p }   \TREF^{  r _{ \mathit{x} , n , p }  } 
\end{align*}
$  \varphi _{ \mathit{x} , n , p }  ( \nu ;   \ottkw{FV} _{ p }  ) $ denotes a fresh relation symbol
applied to $\nu$ and the free variables of simple type $ \TINT $
at program point $p$ (denoted $ \ottkw{FV} _{ p } $). $ r _{ \mathit{x} , n , p } $ is a
fresh ownership variable. For each function $\mathit{f}$,
there are two synthetic program points, $ { \mathit{f} ^{b} } $ and $ { \mathit{f} ^{e} } $
for the beginning and end of the function respectively.
At both points, \name generates type template for each argument, where $ \ottkw{FV} _{  { \mathit{f} ^{b} }  } $
and $ \ottkw{FV} _{  { \mathit{f} ^{e} }  } $ are the names of integer typed parameters.
At $ { \mathit{f} ^{e} } $, \name also generates a type template for the return
value.
We write $ \Gamma ^ p $ to indicate the type environment at point $p$,
where every variable is mapped to its corresponding type template.
$ \sem{  \Gamma ^ p  } $ is thus equivalent to
$ \bigwedge_{  \mathit{x}  \in   \ottkw{FV} _{ p }   }    \varphi _{ \mathit{x} , \ottsym{0} , p }  ( \mathit{x} ;   \ottkw{FV} _{ p }  )  $.

When generating these type templates, our implementation
also generates ownership well-formedness constraints. Specifically,
for a type template of the form $  \set{  \nu  \COL \TINT \mid    \varphi _{ \mathit{x} , n  \ottsym{+}  \ottsym{1} , p }  ( \nu ;   \ottkw{FV} _{ p }  )  }   \TREF^{  r _{ \mathit{x} , n , p }  } $
\name emits the constraint: $ r _{ \mathit{x} , n , p }   \ottsym{=}  \ottsym{0}  \implies    \varphi _{ \mathit{x} , n  \ottsym{+}  \ottsym{1} , p }  ( \nu ;   \ottkw{FV} _{ p }  ) $
and for a type template $ \ottsym{(}   \tau  \TREF^{  r _{ \mathit{x} , n  \ottsym{+}  \ottsym{1} , p }  }   \ottsym{)}  \TREF^{  r _{ \mathit{x} , n , p }  } $
\name emits the constraint $ r _{ \mathit{x} , n , p }   \ottsym{=}  \ottsym{0}  \implies   r _{ \mathit{x} , n  \ottsym{+}  \ottsym{1} , p }   \ottsym{=}  \ottsym{0}$.

\name then walks the program, generating constraints between
relation symbols and ownership variables according to
the typing rules. These constraints take three forms, ownership
constraints, subtyping constraints, and assertion constraints.
Ownership constraints are simple linear (in)equalities over ownership variables
and constants, according to conditions imposed by the typing
rules. For example, if variable $\mathit{x}$ has the type template
$ \tau  \TREF^{  r _{ \mathit{x} , \ottsym{0} , p }  } $ for the expression $ \mathit{x}  \WRITE  \mathit{y}  \SEQ  \ottnt{e} $ at point
$p$, \name generates the constraint $ r _{ \mathit{x} , \ottsym{0} , p }   \ottsym{=}  \ottsym{1}$.

\name emits subtyping constraints between the relation symbols
at related program points according to the rules of the type system.
For example, for the term $ \LET  \mathit{x}  =  \mathit{y}  \IN  \ottnt{e} $
at program point $p$ (where $\ottnt{e}$ is at program point $p'$, and $\mathit{x}$ has simple type
$  \TINT   \TREF $) \name generates the following subtyping constraint:
\[
   \sem{  \Gamma ^ p  }   \wedge    \varphi _{ \mathit{y} , \ottsym{1} , p }  ( \nu ;   \ottkw{FV} _{ p }  )   \implies    \varphi _{ \mathit{y} , \ottsym{1} , p' }  ( \nu ;   \ottkw{FV} _{ p' }  )   \wedge    \varphi _{ \mathit{x} , \ottsym{1} , p' }  ( \nu ;   \ottkw{FV} _{ p' }  ) 
\]
in addition to the ownership constraint $ r _{ \mathit{y} , \ottsym{0} , p }   \ottsym{=}    r _{ \mathit{y} , \ottsym{0} , p' }   \ottsym{+}  r _{ \mathit{x} , \ottsym{0} , p' } $.

Finally, for each \lstinline[mathescape]{assert($\varphi$)} in the program, \name emits an assertion
constraint of the form: $ \sem{  \Gamma ^ p  }   \implies  \varphi$
which requires the refinements on integer typed variables
in scope are sufficient to prove $\varphi$.

\paragraph{Encoding Context Sensitivity.}
To make inference tractable, we require the user to fix \emph{a
  priori} the maximum length of prefix queries to a constant $k$ (this
choice is easily controlled with a command line parameter to our tool). We
supplement the arguments in \emph{every} predicate application with a set of
integer context variables $ \mathit{c_{{\mathrm{1}}}} ,\ldots, \mathit{c_{\ottmv{k}}} $; these variables do not
overlap with any program variables.\looseness=-1

\name uses these variables to infer context sensitive
refinements as follows. Consider a function call
$ \LET  \mathit{x}  =   \mathit{f} ^ \ell (  \mathit{y_{{\mathrm{1}}}} ,\ldots, \mathit{y_{\ottmv{n}}}  )   \IN  \ottnt{e} $ at point $p$
where $\ottnt{e}$ is at point $p'$.
\name generates the following constraint for a refinement
$  \varphi _{ \mathit{y_{\ottmv{i}}} , n , p }  ( \nu ,  \mathit{c_{{\mathrm{1}}}} ,\ldots, \mathit{c_{\ottmv{k}}}  ;  \ottkw{FV} _{ p }  ) $ which occurs in the type template of $\mathit{y_{\ottmv{i}}}$:
\begin{align*}
  &     \varphi _{ \mathit{y_{\ottmv{i}}} , n , p }  ( \nu ,  \mathit{c_{{\mathrm{0}}}} ,\ldots, \mathit{c_{\ottmv{k}}}  ;  \ottkw{FV} _{ p }  )   \implies  \sigma_{x} \, \varphi _{ \mathit{x_{\ottmv{i}}} , n ,  { \mathit{f} ^{b} }  }  ( \nu , \ell  \ottsym{,}   \mathit{c_{{\mathrm{0}}}} ,\ldots, \mathit{c_{{\ottmv{k}-1}}}  ;  \ottkw{FV} _{  { \mathit{f} ^{b} }  }  )  \\
  &     \sigma_{x} \, \varphi _{ \mathit{x_{\ottmv{i}}} , n ,  { \mathit{f} ^{e} }  }  ( \nu , \ell  \ottsym{,}   \mathit{c_{{\mathrm{0}}}} ,\ldots, \mathit{c_{{\ottmv{k}-1}}}  ;  \ottkw{FV} _{  { \mathit{f} ^{e} }  }  )   \implies  \varphi _{ \mathit{y_{\ottmv{i}}} , n , p' }  ( \nu ,  \mathit{c_{{\mathrm{0}}}} ,\ldots, \mathit{c_{\ottmv{k}}}  ;  \ottkw{FV} _{ p' }  )  \\
  & \sigma_{x}  \ottsym{=}    [  \mathit{y_{{\mathrm{1}}}}  /  \mathit{x_{{\mathrm{1}}}}  ]  \cdots  [  \mathit{y_{\ottmv{n}}}  /  \mathit{x_{\ottmv{n}}}  ]  
\end{align*}
Effectively, we have encoded $   \ell_{{\mathrm{1}}} \ldots \ell_{\ottmv{k}}      \preceq    \lambda $ as $\land_{0<i\leq k} c_i = \ell_{\ottmv{i}}$.
In the above, the shift from $ \mathit{c_{{\mathrm{0}}}} ,\ldots, \mathit{c_{\ottmv{k}}} $ to $\ell  \ottsym{,}   \mathit{c_{{\mathrm{0}}}} ,\ldots, \mathit{c_{{\ottmv{k}-1}}} $ plays the role of
$\sigma_{\alpha}$ in the \rn{T-Call} rule. The above constraint serves to
determine the value of $\mathit{c_{{\mathrm{0}}}}$ within the body of the function $\mathit{f}$.
If $\mathit{f}$ calls another function $\mathit{g}$, the above rule
propagates this value of $\mathit{c_{{\mathrm{0}}}}$ to $\mathit{c_{{\mathrm{1}}}}$ within $\mathit{g}$ and so on.
The solver may then instantiate relation symbols with predicates
that are conditional over the values of $\mathit{c_{\ottmv{i}}}$.

\paragraph{Solving Constraints.}
The results of the above process are two systems of constraints;
real arithmetic constraints over
ownership variables and constrained Horn clauses (CHC) over the refinement relations.
Under certain assumptions about the simple types in a program, the size of the ownership
and subtyping constraints will be polynomial to the size of the program.
These systems are not independent; the relation constraints may mention the value
of ownership variables due to the well-formedness constraints described above.
The ownership constraints are first solved with Z3 \cite{de2008z3}. These constraints
are non-linear but Z3 appears
particularly well-engineered to quickly find solutions for the instances generated
by \name.
We constrain Z3 to maximize the number of non-zero ownership
variables to ensure as few refinements as possible are constrained to be $ \top $ by ownership well-formedness.

The values of ownership variables inferred by Z3 are then substituted into the
constrained Horn clauses, and the resulting system is checked
for satisfiability with an off-the-shelf CHC solver.
Our implementation generates constraints in the industry standard
SMT-Lib2 format \cite{BarFT-SMTLIB}; any solver that accepts
this format can be used as a backend for \name. Our implementation
currently supports Spacer \cite{komuravelli2013automatic} (part of the Z3 solver \cite{de2008z3}),
HoICE \cite{champion2018hoice}, and Eldarica \cite{rummer2013disjunctive}
(adding a new backend requires only a handful of lines of glue code).
We found that different solvers are better tuned to different problems;
we also implemented \emph{parallel mode} which runs all supported solvers
in parallel, using the first available result.

\subsection{Extensions}

\paragraph{Primitive Operations.}
As defined in \Cref{sec:prelim}, our language can compare integers to zero and load
and store them from memory, but can perform no meaningful computation
over these numbers. To promote the flexibility of our type system and simplify
our soundness statement, we do not
fix a set of primitive operations and their static semantics.
Instead, we assume any set of primitive operations
used in a program are given sound function types in $\Theta$.
For example, under the assumption that $+$ has its usual semantics
and the underlying logic supports $+$, we can give $+$ the type
$ \forall  \lambda .\tuple{ \mathit{x}  \ottsym{:}  \top_{{\mathrm{0}}}  \ottsym{,}  \mathit{y}  \ottsym{:}  \top_{{\mathrm{0}}} }\ra\tuple{ \mathit{x}  \ottsym{:}  \top_{{\mathrm{0}}}  \ottsym{,}  \mathit{y}  \ottsym{:}  \top_{{\mathrm{0}}} \mid  \set{  \nu  \COL \TINT \mid  \nu \, \ottsym{=} \, \mathit{x}  \ottsym{+}  \mathit{y} }  } $.
Interactions with a nondeterministic environment
or unknown program inputs can then be modeled with a primitive
that returns integers refined with $ \top $.


\paragraph{Dependent Tuples.}
Our implementation supports types of the form: $( \mathit{x_{{\mathrm{1}}}} : \tau_{{\mathrm{1}}}, \ldots,$ $\mathit{x_{\ottmv{n}}}:\tau_{\ottmv{n}})$,
where $\mathit{x_{\ottmv{i}}}$ can appear within $\tau_{\ottmv{j}}$
($j\neq i$) if $\tau_{\ottmv{i}}$ is an integer type. For example,
$\ottsym{(}   \mathit{x} \COL  \set{  \nu  \COL \TINT \mid   \top  }    \ottsym{,}  \mathit{y}  \ottsym{:}   \set{  \nu  \COL \TINT \mid  \nu \, \ottsym{>} \, \mathit{x} }   \ottsym{)}$ is the type of tuples whose
second element is strictly greater than the first. We also extend
the language with tuple constructors as a new value form, and
let bindings with tuple patterns as the LHS.

The extension to type checking is relatively straightforward; the only
significant extensions are to the subtyping rules.
Specifically, the subtyping check for a tuple element
$ \mathit{x_{\ottmv{i}}} \COL \tau_{\ottmv{i}} $ is performed in a type environment elaborated with the
types and names of other tuple elements.
The extension to type inference is also
straightforward; the arguments for a
predicate symbol include any enclosing dependent tuple names
and the environment in subtyping constraints is likewise extended.

\paragraph{Recursive Types.}
Our language also supports some unbounded heap structures via recursive
reference types. To keep inference tractable, we forbid nested
recursive types, multiple occurrences of the recursive type variable,
and additionally fix the shape of refinements that occur within a
recursive type. For recursive refinements that fit the
above restriction, our approach for refinements
is broadly similar to that in \cite{kawaguchi2009type}, and we use
the ownership scheme of \cite{suenaga2009fractional} for handling
ownership. We first use simple type inference
to infer the shape of the recursive types, and automatically insert
fold/unfold annotations into the source program. As in
\cite{kawaguchi2009type},
the refinements within an unfolding of a recursive type may refer to
dependent tuple names bound by the enclosing type. These recursive
types can express, e.g., the invariants of a mutable,
sorted list. As in \cite{suenaga2009fractional},
recursive types are unfolded once before assigning ownership variables;
further unfoldings copy existing ownership variables.\looseness=-1

As in Java or C++, our language does not support sum types,
and any instantiation of a recursive type must use a null pointer.
Our implementation supports an \lstinline{ifnull} construct
in addition to a distinguished \lstinline{null} constant. Our implementation allows any refinement
to hold for the null constant, including $\bot$. Currently, our implementation
does \emph{not} detect null pointer dereferences, and all soundness
guarantees are made modulo freedom of null dereferences. As $ \sem{ \Gamma } $
omits refinements under reference types, null pointer refinements do not affect
the verification of programs without null pointer dereferences.

\paragraph{Arrays.}
Our implementation supports arrays of integers. Each array is given
an ownership describing the ownership of memory allocated for the entire array.
The array type contains two refinements: the first refines the length of the array itself,
and the second refines the entire array contents.
The content refinement may refer to a symbolic index variable
for precise, per-index refinements. At reads and writes to the
array, \name instantiates the refinement's symbolic index variable with
the concrete index used at the read/write.

As in \cite{suenaga2009fractional}, our restriction to arrays of integers
stems from the difficulty of ownership inference. Soundly handling
pointer arrays requires index-wise tracking of ownerships which
significantly complicates automated inference. We leave supporting
arrays of pointers to future work.

\subsection{Limitations}
Our current approach is not complete; there are safe programs that will be
rejected by our type system.
As mentioned in \Cref{sec:types}, our well-formedness
condition forbids refinements that refer to memory locations. As a result,
\name cannot in general express, e.g., that the contents of two references are equal.
Further, due to our reliance on automated theorem provers
we are restricted to logics with sound but potentially incomplete decision procedures.
\name also does not support conditional or context-sensitive ownerships, and therefore
cannot precisely handle conditional mutation or aliasing.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:

%  LocalWords:  formedness ownerships satisfiability dereferences
%  LocalWords:  provers equalities
