\section{Typing}
\label{sec:typesystem}
We now introduce a
fractional ownership refinement type system that guarantees well-typed
programs do not encounter assertion failures.
% We first present
% a brief background on ownership types (\Cref{sec:ownership}),
% before describing our fractional ownership refinement types
% (\Cref{sec:types}), the type system (\Cref{sec:intra-types,sec:cs}),
% and finally close with our soundness statement
% (\Cref{sec:soundness}).

% \subsection{Background: Fractional Ownership Types}
% \label{sec:ownership}
% Before describing our type system in detail, we provide a brief
% overview of the fractional ownership type system upon which it
% is built. The fractional ownership types of
% Suenaga and Kobayashi \cite{suenaga2009fractional}
% ensures safe memory access in low-level languages like C; it
% was later extended by Suenaga et al. \cite{suenaga2012type} to also guarantee
% correct allocation/deallocation of shared resources in concurrent programs.
% Fractional ownership types elaborate reference
% types with a rational number $r$ in the range $[0,1]$ called an \emph{ownership}.
% In the original paper, an ownership of
% $\ottsym{1}$ indicates that a pointer
% has exclusive ownership of a memory cell and may read or write
% the contents of the cell. Ownership in the range $(0,1)$
% indicates a pointer with shared ownership through which
% the cell can be read but \emph{not} modified. Finally, a pointer
% with $0$ ownership may be neither read nor written.

% The fractional ownership type systems in \cite{suenaga2009fractional,suenaga2012type} enforced the
% following key invariant: the total ownership of all pointer types that
% point to the same memory cell never exceeds 1. As an immediate
% consequence, given a pointer $p$ with ownership $1$, no other readable
% pointers that alias with $p$ may exist (otherwise the total ownership
% would exceed 1). The type system is designed such that when an alias
% to a pointer $p$ is created, the current ownership of $p$ is divided
% between the new alias and $p$ (hence \emph{fractional} ownership).
% Further, on writes to a reference $p$,
% the type system may destructively change
% the type of $p$'s contents to be inconsistent with previous content type.
% In a language with unrestricted aliasing, such an operation would
% be unsound, but the above invariant guarantees that
% at the time of update no readable pointers that expect the old
% contents remain.
% \name maintains the same invariant; this guarantee enables our combined
% type system to destructively
% (and incompatibly) change the refinements of mutable memory cells;
% pointers with inconsistent refinements cannot exist when an update occurs.

% \begin{remark}
%   In the fractional ownership type systems cited above,
%   an ownership also represents an \emph{obligation} to
%   ensure memory referenced by a pointer is eventually
%   freed. Further, pointers to freed memory
%   are given $0$ ownership to prevent use-after-free errors.
%   As mentioned in \Cref{sec:semantics}, our language
%   does not include deallocation which
%   significantly simplifies our formalism.
%   In particular, our type system \emph{does}
%   allow reads of references with 0 ownerships. However,
%   such references provide no information about their contents
%   beyond simple types for reasons discussed below.
% \end{remark}

\begin{figure}[t]
  \begin{minipage}{0.2\textwidth}
  \[
    \begin{array}{rrcl}
      \text{\scriptsize Types} & \tau % & \in & \mathbf{Types} \\
                                         &::=&  \set{  \nu  \COL \TINT \mid  \varphi }  \mid  \tau  \TREF^{ r }  \\
      \text{\scriptsize Ownership} & r & \in & [0,1] \\
      \text{\scriptsize Refinements} & \varphi & ::= & \varphi_{{\mathrm{1}}}  \vee  \varphi_{{\mathrm{2}}} \mid  \neg  \varphi  \mid  \top  \\
                               & & \mid & \phi  \ottsym{(}  \widehat{v}_{{\mathrm{1}}}  \ottsym{,} \, .. \, \ottsym{,}  \widehat{v}_{\ottmv{n}}  \ottsym{)} \\
                               & & \mid & \widehat{v}_{{\mathrm{1}}} \, \ottsym{=} \, \widehat{v}_{{\mathrm{2}}} \\
                                 & & \mid & \mathcal{CP} \\
      \text{\scriptsize Ref. Values} & \widehat{v} & ::= & \mathit{x} \mid n \mid \nu \\
%      \text{\scriptsize Type Env.} & \Gamma & \in & \mathbf{Var} \ra_{\textrm{fin}} \mathbf{Types}
    \end{array}
  \]
\end{minipage}
\hfill
\begin{minipage}{0.59\textwidth}
  \[
    \begin{array}{rrcl}
      \text{\scriptsize Function Types} & \sigma & ::= &  \forall  \lambda .\tuple{ \mathit{x_{{\mathrm{1}}}} \COL \tau_{{\mathrm{1}}} ,\dots, \mathit{x_{\ottmv{n}}} \COL \tau_{\ottmv{n}} } \\ & & & \ra\tuple{ \mathit{x_{{\mathrm{1}}}} \COL \tau'_{{\mathrm{1}}} ,\dots, \mathit{x_{\ottmv{n}}} \COL \tau'_{\ottmv{n}}  \mid  \tau }  \\
      \text{\scriptsize Context Variables} & \lambda & \in & \CVar \\
      \text{\scriptsize Concrete Context} & \oldvec{\ell} & ::= & \ell  \ottsym{:}  \oldvec{\ell} \mid  \epsilon  \\
      \text{\scriptsize Pred. Context} & \mathcal{C} & ::= &  \ell  :  \mathcal{C}  \mid \lambda \mid  \epsilon  \\
      \text{\scriptsize Context Query} & \mathcal{CP} & ::= &   \oldvec{\ell}     \preceq    \mathcal{C}  \\
      \text{\scriptsize Typing Context} & \mathcal{L} & ::= & \lambda \mid \oldvec{\ell} \\
%      \text{\scriptsize Function Env.} & \Theta & \in & \mathit{f} \ra \sigma 
    \end{array}
  \]
  \end{minipage}
  \caption{Syntax of types, refinements, and contexts.}
  \label{fig:types}
\end{figure}

\subsection{Types and Contexts}
\label{sec:types}
The syntax of types is given in \Cref{fig:types}.
Our type system has two type constructors: references and integers. $ \tau  \TREF^{ r } $ is the
type of a (non-null) reference to a value of type $\tau$.
$r$ is an ownership which is a rational number in the
range $[0,1]$. An ownership of $\ottsym{0}$ indicates a
reference that cannot be written,
and for which there may exist a mutable alias.
By contrast, $\ottsym{1}$ indicates a pointer with exclusive
ownership that can be read and written. Reference types with ownership values between
these two extremes indicate a pointer that is readable but not writable, and for which no mutable aliases exist.
% Like the ownership type systems described above,
\name ensures that these
invariants hold while aliases are created and destroyed during execution.

Integers are refined with a predicate $\varphi$.  The language of predicates is built using the
standard logical connectives of first-order logic,
with (in)equality between variables and integers, and atomic predicate symbols
$\phi$ as the basic atoms. We include a special
``value'' variable $\nu$ representing the
value being refined by the predicate. For simplicity, we omit the
connectives $ \varphi_{{\mathrm{1}}}  \wedge  \varphi_{{\mathrm{2}}} $ and $\varphi_{{\mathrm{1}}}  \implies  \varphi_{{\mathrm{2}}}$; they can be written
as derived forms using the given connectives.
We do not fix a particular theory from which $\phi$ are drawn, provided a sound
(but not necessarily complete) decision procedure exists.
$\mathcal{CP}$ are context predicates, which are used for context sensitivity as
explained below.

\begin{example}
  $ \set{  \nu  \COL \TINT \mid  \nu \, \ottsym{>} \, \ottsym{0} } $ is the type of strictly positive integers.
  The type of immutable
  references to integers exactly equal to $3$ can be expressed by
  $  \set{  \nu  \COL \TINT \mid  \nu \, \ottsym{=} \, \ottsym{3} }   \TREF^{ \ottsym{0}  \ottsym{.}  \ottsym{5} } $.
\end{example}

As is standard, we denote a type environment with $\Gamma$, which is a
finite map from variable names to type $\tau$.
We write $\Gamma  \ottsym{[}  \mathit{x}  \ottsym{:}  \tau  \ottsym{]}$ to denote a type environment $\Gamma$ such
that $\Gamma  \ottsym{(}  \mathit{x}  \ottsym{)}  \ottsym{=}  \tau$ where $ \mathit{x}  \in   \DOM( \Gamma )  $, $\Gamma  \ottsym{,}  \mathit{x}  \ottsym{:}  \tau$ to indicate the
extension of $\Gamma$ with the type binding $ \mathit{x} \COL \tau $, and $\Gamma  \ottsym{[}  \mathit{x}  \hookleftarrow  \tau  \ottsym{]}$
to indicate the type environment $\Gamma$ with the binding of $\mathit{x}$
updated to $\tau$. We write the empty environment as $ \bullet $.
The treatment of type environments as mappings instead of sequences
in a dependent type system is somewhat non-standard.
The standard formulation based on ordered sequences of bindings and
its corresponding well-formedness condition did not easily admit
variables with mutually dependent refinements as introduced by
our function types (see below). We therefore use an unordered
environment and relax well-formedness to ignore variable binding order.

\paragraph{Function Types, Contexts, and Context Polymorphism.}
Our type system achieves context sensitivity
by allowing function types to depend on where a function
is called, i.e., the \emph{execution context} of the function invocation.
Our system represents a \emph{concrete} execution contexts with
strings of call site labels (or just ``call strings''),
defined by $\oldvec{\ell} ::=  \epsilon  \mid \ell  \ottsym{:}  \oldvec{\ell}$.
As is standard (e.g., \cite{sharir1978two,shivers1991control}), the string $\ell  \ottsym{:}  \oldvec{\ell}$ abstracts
an execution context where the most recent, active function call occurred
at call site $\ell$ which itself was executed in a context abstracted
by $\oldvec{\ell}$; $ \epsilon $ is the context under which program execution begins. \emph{Context variables},
drawn from a finite domain $\CVar$ and ranged over by $\lambda_{{\mathrm{1}}}, \lambda_{{\mathrm{2}}}, \ldots$,
represent arbitrary, unknown contexts.\looseness=-1

A function type takes the form
$ \forall  \lambda .\tuple{ \mathit{x_{{\mathrm{1}}}} \COL \tau_{{\mathrm{1}}} ,\dots, \mathit{x_{\ottmv{n}}} \COL \tau_{\ottmv{n}} }\ra\tuple{ \mathit{x_{{\mathrm{1}}}} \COL \tau'_{{\mathrm{1}}} ,\dots, \mathit{x_{\ottmv{n}}} \COL \tau'_{\ottmv{n}}  \mid  \tau } $.
The arguments of a function are an $n$-ary tuple of types $\tau_{\ottmv{i}}$.
To model side-effects on arguments, the function type includes the same number of \emph{output types}
$\tau'_{\ottmv{i}}$. In addition, function types have a direct return type $\tau$. 
The argument and output types are given names: refinements within the function type
may refer to these names.
Function types in our language are context polymorphic,
expressed by universal quantification ``$\forall \lambda.$''
over a context variable. Intuitively,
this context variable represents the many different execution contexts
under which a function may be called.

Argument and return types may depend on this context variable by
including \emph{context query predicates} in their refinements.
A context query predicate $\mathcal{CP}$ usually takes the
form $  \oldvec{\ell}     \preceq    \lambda $, and is true iff $\oldvec{\ell}$ is a
prefix of the concrete context represented by $\lambda$.
Intuitively, a refinement $  \oldvec{\ell}     \preceq    \lambda   \implies  \varphi$
states that $\varphi$ holds in any concrete execution context
with prefix $\oldvec{\ell}$, and provides no information in any other
context. In full generality, a context query predicate may
be of the form $  \oldvec{\ell}_{{\mathrm{1}}}     \preceq    \oldvec{\ell}_{{\mathrm{2}}} $ or $  \oldvec{\ell}     \preceq     \ell_{{\mathrm{1}}} \ldots \ell_{\ottmv{n}}   \ottsym{:}  \lambda $;
these forms may be immediately simplified to
$ \top $, $ \bot $ or $  \oldvec{\ell}'     \preceq    \lambda $.

\begin{example}
  \label{exmp:cs-type-example}
  The type $ \set{  \nu  \COL \TINT \mid   \ottsym{(}    \ell_{{\mathrm{1}}}     \preceq    \lambda   \implies  \nu \, \ottsym{=} \, \ottsym{3}  \ottsym{)}  \wedge  \ottsym{(}    \ell_{{\mathrm{2}}}     \preceq    \lambda   \implies  \nu \, \ottsym{=} \, \ottsym{5}  \ottsym{)}  } $ represents
  an integer that is 3 if the most recent active
  function call site is $\ell_{{\mathrm{1}}}$, 5 if the most recent call site is $\ell_{{\mathrm{2}}}$,
  and is otherwise unconstrained. This type may be used for the argument of
  \imp{f} in, e.g., \imp[mathescape]{f$^{\ell_{{\mathrm{1}}}}$(3) + f$^{\ell_{{\mathrm{2}}}}$(5)}.
\end{example}

As types in our type system may contain context variables, our typing judgment
(introduced below) includes a typing context $\mathcal{L}$, which is either a single
context variable $\lambda$ or a concrete context $\oldvec{\ell}$. This typing context
represents the assumptions about the execution context of the term being
typed. If the typing context is a context variable $\lambda$, then no assumptions
are made about the execution context of the term, although types
may depend upon $\lambda$ with context query predicates.
Accordingly, function bodies are typed under the context variable
universally quantified over in the corresponding function type; i.e.,
no assumptions are made about the exact execution context of the function body.
As in parametric polymorphism, consistent
substitution of a concrete context $\oldvec{\ell}$ for a context variable $\lambda$
in a typing derivation yields a valid type derivation under concrete context $\oldvec{\ell}$.

\begin{remark}
  \label{rem:cfa}
  The context-sensitivity scheme described here corresponds
  to the standard CFA approach \cite{shivers1991control} without \emph{a priori} call-string limiting.
  We chose this scheme because it can be easily encoded with equality over integer variables (see \Cref{sec:infr}),
  but in principle another context-sensitivity strategy could be used instead. The important
  feature of our type system is the inclusion of predicates over
  contexts, not the specific choice for these predicates.
\end{remark}

Function type environments are denoted with $\Theta$ and are finite
maps from function names ($\mathit{f}$) to function types ($\sigma$).

\paragraph{Well Formedness.}
We impose two well-formedness conditions on types:
\emph{ownership well-formedness} and \emph{refinement well-formedness}.
The ownership condition is purely syntactic:
$\tau$ is ownership well-formed if $\tau  \ottsym{=}   \tau'  \TREF^{ \ottsym{0} } $ implies
$\tau'  \ottsym{=}  \top_{\ottmv{n}}$ for some $\ottmv{n}$. $\top_{\ottmv{i}}$ is the ``maximal'' type
of a chain of $\ottmv{i}$ references, and is defined inductively as
$\top_{{\mathrm{0}}}  \ottsym{=}   \set{  \nu  \COL \TINT \mid   \top  } , \top_{\ottmv{i}}  \ottsym{=}   \top_{{\ottmv{i}-1}}  \TREF^{ \ottsym{0} } $.

The ownership well-formedness condition ensures that aliases introduced via
heap writes do not violate the invariant of ownership types \emph{and} that refinements
are consistent with updates performed through mutable aliases. Recall our ownership type invariant
ensures all aliases of a mutable reference have 0 ownership.
Any mutations through that mutable alias will therefore be consistent with the
``no information'' $ \top $ refinement required by this
well-formedness condition.

Refinement well-formedness, denoted $ \mathcal{L}   \mid   \Gamma   \vdash _{\wf}  \varphi $,
ensures that free program variables in refinement $\varphi$ are
bound in a type environment $\Gamma$ and have integer type. It
also requires that for a typing context
$\mathcal{L}  \ottsym{=}  \lambda$, only context query predicates over $\lambda$ are used (no such
predicates may be used if $\mathcal{L}  \ottsym{=}  \oldvec{\ell}$). Notice this condition
forbids refinements that refer to references. Although
ownership information can signal when refinements on a mutably-aliased
reference must be discarded, our current formulation
provides no such information for refinements that \emph{mention}
mutably-aliased references. We therefore conservatively reject
such refinements at the cost of some expressiveness in our type system.

We write $ \mathcal{L}   \mid   \Gamma   \vdash _{\wf}  \tau $ to indicate a well-formed type where
all refinements are well-formed with respect to $\mathcal{L}$ and $\Gamma$.
We write $ \mathcal{L}   \vdash _{\wf}  \Gamma $ for a type environment where all
types are well-formed. A function environment
is well-formed (written $ \vdash _{\wf}  \Theta $) if, for every $\sigma$ in $\Theta$,
the argument, result, and output types are well-formed with respect
to each other and the context variable quantified over in $\sigma$.
As the formal definition of refinement well-formedness is fairly standard, we
omit it for space reasons (the full definition may be found in \appref{\Cref{sec:aux-defn-lem}}{the full version \cite{toman2020consort}}).

\begin{figure}[t]
%  \leavevmode
  \scriptsize
  \infrule[T-Var]{
  }{
     \Theta   \mid   \mathcal{L}   \mid   \Gamma  \ottsym{[}  \mathit{x}  \ottsym{:}  \tau_{{\mathrm{1}}}  \ottsym{+}  \tau_{{\mathrm{2}}}  \ottsym{]}   \vdash   \mathit{x}  :  \tau_{{\mathrm{1}}}   \produces   \Gamma  \ottsym{[}  \mathit{x}  \hookleftarrow  \tau_{{\mathrm{2}}}  \ottsym{]} 
  }
  \vspace*{2ex}
  \infrule[T-Let]{
     \Theta   \mid   \mathcal{L}   \mid   \Gamma  \ottsym{[}  \mathit{y}  \hookleftarrow   \tau_{{\mathrm{1}}}  \wedge_{ \mathit{y} }   \mathit{y}  =_{ \tau_{{\mathrm{1}}} }  \mathit{x}    \ottsym{]}  \ottsym{,}  \mathit{x}  \ottsym{:}  \ottsym{(}   \tau_{{\mathrm{2}}}  \wedge_{ \mathit{x} }   \mathit{x}  =_{ \tau_{{\mathrm{2}}} }  \mathit{y}    \ottsym{)}   \vdash   \ottnt{e}  :  \tau   \produces   \Gamma'  \andalso
     \mathit{x}  \not\in   \DOM( \Gamma' )  
  }{
     \Theta   \mid   \mathcal{L}   \mid   \Gamma  \ottsym{[}  \mathit{y}  \ottsym{:}  \tau_{{\mathrm{1}}}  \ottsym{+}  \tau_{{\mathrm{2}}}  \ottsym{]}   \vdash    \LET  \mathit{x}  =  \mathit{y}  \IN  \ottnt{e}   :  \tau   \produces   \Gamma' 
  }
  \vspace*{2ex}
  \infrule[T-LetInt]{
     \Theta   \mid   \mathcal{L}   \mid   \Gamma  \ottsym{,}  \mathit{x}  \ottsym{:}   \set{  \nu  \COL \TINT \mid  \nu \, \ottsym{=} \, n }    \vdash   \ottnt{e}  :  \tau   \produces   \Gamma'  \andalso
     \mathit{x}  \not\in   \DOM( \Gamma' )  
  }{
     \Theta   \mid   \mathcal{L}   \mid   \Gamma   \vdash    \LET  \mathit{x}  =  n  \IN  \ottnt{e}   :  \tau   \produces   \Gamma' 
  }
  \vspace*{2ex}
  \infrule[T-If]{
     \Theta   \mid   \mathcal{L}   \mid   \Gamma  \ottsym{[}  \mathit{x}  \hookleftarrow   \set{  \nu  \COL \TINT \mid   \varphi  \wedge  \nu \, \ottsym{=} \, \ottsym{0}  }   \ottsym{]}   \vdash   \ottnt{e_{{\mathrm{1}}}}  :  \tau   \produces   \Gamma'  \\
     \Theta   \mid   \mathcal{L}   \mid   \Gamma  \ottsym{[}  \mathit{x}  \hookleftarrow   \set{  \nu  \COL \TINT \mid   \varphi  \wedge  \nu \, \neq \, \ottsym{0}  }   \ottsym{]}   \vdash   \ottnt{e_{{\mathrm{2}}}}  :  \tau   \produces   \Gamma' 
  }{
     \Theta   \mid   \mathcal{L}   \mid   \Gamma  \ottsym{[}  \mathit{x}  \ottsym{:}   \set{  \nu  \COL \TINT \mid  \varphi }   \ottsym{]}   \vdash    \IFZERO  \mathit{x}  \THEN  \ottnt{e_{{\mathrm{1}}}}  \ELSE  \ottnt{e_{{\mathrm{2}}}}   :  \tau   \produces   \Gamma' 
  }
  \vspace*{2ex}
  \bcprulessavespacetrue
  \begin{center}
  \infrule[T-MkRef]{
     \Theta   \mid   \mathcal{L}   \mid   \Gamma  \ottsym{[}  \mathit{y}  \hookleftarrow  \tau_{{\mathrm{1}}}  \ottsym{]}  \ottsym{,}  \mathit{x}  \ottsym{:}   \ottsym{(}   \tau_{{\mathrm{2}}}  \wedge_{ \mathit{x} }   \mathit{x}  =_{ \tau_{{\mathrm{2}}} }  \mathit{y}    \ottsym{)}  \TREF^{ \ottsym{1} }    \vdash   \ottnt{e}  :  \tau   \produces   \Gamma'  \\
     \mathit{x}  \not\in   \DOM( \Gamma' )  
  }{
     \Theta   \mid   \mathcal{L}   \mid   \Gamma  \ottsym{[}  \mathit{y}  \ottsym{:}  \tau_{{\mathrm{1}}}  \ottsym{+}  \tau_{{\mathrm{2}}}  \ottsym{]}   \vdash    \LET  \mathit{x}  =   \MKREF  \mathit{y}   \IN  \ottnt{e}   :  \tau   \produces   \Gamma' 
  }
  \infrule[T-Seq]{
     \Theta   \mid   \mathcal{L}   \mid   \Gamma   \vdash   \ottnt{e_{{\mathrm{1}}}}  :  \tau'   \produces   \Gamma'  \\
     \Theta   \mid   \mathcal{L}   \mid   \Gamma'   \vdash   \ottnt{e_{{\mathrm{2}}}}  :  \tau''   \produces   \Gamma'' 
  }{
     \Theta   \mid   \mathcal{L}   \mid   \Gamma   \vdash    \ottnt{e_{{\mathrm{1}}}}  \SEQ  \ottnt{e_{{\mathrm{2}}}}   :  \tau''   \produces   \Gamma'' 
  }
  \infrule[T-Deref]{
    \tau' = \begin{cases}
       \tau_{{\mathrm{1}}}  \wedge_{ \mathit{y} }   \mathit{y}  =_{ \tau_{{\mathrm{1}}} }  \mathit{x}   &  r   \ottsym{>}   \ottsym{0}  \\
      \tau_{{\mathrm{1}}} & r  \ottsym{=}  \ottsym{0}
    \end{cases}  \\
     \Theta   \mid   \mathcal{L}   \mid   \Gamma  \ottsym{[}  \mathit{y}  \hookleftarrow   \tau'  \TREF^{ r }   \ottsym{]}  \ottsym{,}  \mathit{x}  \ottsym{:}  \tau_{{\mathrm{2}}}   \vdash   \ottnt{e}  :  \tau   \produces   \Gamma'  \\
     \mathit{x}  \not\in   \DOM( \Gamma' )  
  }{
     \Theta   \mid   \mathcal{L}   \mid   \Gamma  \ottsym{[}  \mathit{y}  \ottsym{:}   \ottsym{(}  \tau_{{\mathrm{1}}}  \ottsym{+}  \tau_{{\mathrm{2}}}  \ottsym{)}  \TREF^{ r }   \ottsym{]}   \vdash    \LET  \mathit{x}  =   *  \mathit{y}   \IN  \ottnt{e}   :  \tau   \produces   \Gamma' 
  }
  \infrule[T-Assert]{
    \Gamma  \models  \varphi \andalso
      \epsilon    \mid   \Gamma   \vdash _{\wf}  \varphi  \\
     \Theta   \mid   \mathcal{L}   \mid   \Gamma   \vdash   \ottnt{e}  :  \tau   \produces   \Gamma' 
  }{
     \Theta   \mid   \mathcal{L}   \mid   \Gamma   \vdash    \ASSERT( \varphi ) \SEQ  \ottnt{e}   :  \tau   \produces   \Gamma' 
  }
  \end{center}
  \bcprulessavespacefalse
  \caption{Expression typing rules.}
  \label{fig:intra-type}
\end{figure}

% \begin{figure}[t]
%   \leavevmode
%   \infax[Tadd-Int]{
%      \set{  \nu  \COL \TINT \mid  \varphi_{{\mathrm{1}}} }   \ottsym{+}   \set{  \nu  \COL \TINT \mid  \varphi_{{\mathrm{2}}} }   \ottsym{=}   \set{  \nu  \COL \TINT \mid   \varphi_{{\mathrm{1}}}  \wedge  \varphi_{{\mathrm{2}}}  } 
%   }
%   \infax[Tadd-Ref]{
%       \tau_{{\mathrm{1}}}  \TREF^{ r_{{\mathrm{1}}} }   \ottsym{+}  \tau_{{\mathrm{2}}}  \TREF^{ r_{{\mathrm{2}}} }   \ottsym{=}   \ottsym{(}  \tau_{{\mathrm{1}}}  \ottsym{+}  \tau_{{\mathrm{2}}}  \ottsym{)}  \TREF^{ r_{{\mathrm{1}}}  \ottsym{+}  r_{{\mathrm{2}}} } 
%   }
%   \caption{Rules for $\tau_{{\mathrm{1}}}  \ottsym{+}  \tau_{{\mathrm{2}}}$.}
%   \label{fig:addition}
% \end{figure}

\subsection{Intraprocedural Type System}
\label{sec:intra-types}
We now introduce the type system for the intraprocedural fragment of
our language. Accordingly, this section focuses on the interplay of
mutability and refinement types. The typing rules are given in
\Cref{fig:intra-type,fig:pointer-typing}.  
A typing judgment takes the
form $ \Theta   \mid   \mathcal{L}   \mid   \Gamma   \vdash   \ottnt{e}  :  \tau   \produces   \Gamma' $, which indicates that $\ottnt{e}$
is well-typed under a function type
environment $\Theta$, typing context $\mathcal{L}$, and type environment $\Gamma$, 
and evaluates to a value of type $\tau$ and modifies the input environment
according to $\Gamma'$. Any valid typing derivation must
have $ \mathcal{L}   \vdash _{\wf}  \Gamma $, $ \mathcal{L}   \vdash _{\wf}  \Gamma' $, and $ \mathcal{L}   \mid   \Gamma'   \vdash _{\wf}  \tau $, i.e.,
the input and output type environments and result type must
be well-formed.

The typing rules in \Cref{fig:intra-type} handle the relatively
standard features in our language. The rule \rn{T-Seq} for sequential
composition is fairly straightforward except that the output type
environment for $\ottnt{e_{{\mathrm{1}}}}$ is the input type environment for $\ottnt{e_{{\mathrm{2}}}}$.
\rn{T-LetInt} is also straightforward; since $\mathit{x}$ is bound to a
constant, it is given type $ \set{  \nu  \COL \TINT \mid  \nu \, \ottsym{=} \, n } $ to indicate $\mathit{x}$ is
exactly $n$.  The output type environment $\Gamma'$ cannot mention
$\mathit{x}$ (expressed with $ \mathit{x}  \not\in   \DOM( \Gamma' )  $)
to prevent $\mathit{x}$ from escaping its scope.  This requirement
can be met by applying the subtyping rule (see below) to weaken
refinements to no longer mention $\mathit{x}$. As in other refinement type
systems \cite{rondon2008liquid}, this requirement is critical for
ensuring soundness.

Rule \rn{T-Let} is crucial to understanding our ownership type system.
The body of the let expression $\ottnt{e}$ is typechecked under a type environment
where the type of $\mathit{y}$ in $\Gamma$ is linearly split into two types:
$\tau_{{\mathrm{1}}}$ for $\mathit{y}$ and $\tau_{{\mathrm{2}}}$ for the newly created binding $\mathit{x}$.
This splitting is expressed using the $+$ operator. If $\mathit{y}$ is a reference
type, the split operation distributes some portion of $\mathit{y}$'s ownership information
to its new alias $\mathit{x}$. The split operation also distributes
refinement information between the two types.
For example, type $  \set{  \nu  \COL \TINT \mid  \nu \, \ottsym{>} \, \ottsym{0} }   \TREF^{ \ottsym{1} } $ can be split into (1)
$  \set{  \nu  \COL \TINT \mid  \nu \, \ottsym{>} \, \ottsym{0} }   \TREF^{ r } $ and $  \set{  \nu  \COL \TINT \mid  \nu \, \ottsym{>} \, \ottsym{0} }   \TREF^{ \ottsym{(}  \ottsym{1}  \ottsym{-}  r  \ottsym{)} } $ (for $r \in (0,1)$),
i.e., two \emph{immutable} references with non-trivial refinement information,
or (2) $  \set{  \nu  \COL \TINT \mid  \nu \, \ottsym{>} \, \ottsym{0} }   \TREF^{ \ottsym{1} } $ and $  \set{  \nu  \COL \TINT \mid   \top  }   \TREF^{ \ottsym{0} } $, where
one of the aliases is mutable and the other provides no refinement information.
How a type is split depends on the usage of $\mathit{x}$ and $\mathit{y}$ in $\ottnt{e}$.
Formally, we define the type addition operator as
the least commutative partial operation that satisfies the following
rules:\looseness=-1
\begin{align*}
   \set{  \nu  \COL \TINT \mid  \varphi_{{\mathrm{1}}} }   \ottsym{+}   \set{  \nu  \COL \TINT \mid  \varphi_{{\mathrm{2}}} }  & =  \set{  \nu  \COL \TINT \mid   \varphi_{{\mathrm{1}}}  \wedge  \varphi_{{\mathrm{2}}}  }  & (\rn{Tadd-Int})  \\
    \tau_{{\mathrm{1}}}  \TREF^{ r_{{\mathrm{1}}} }   \ottsym{+}  \tau_{{\mathrm{2}}}  \TREF^{ r_{{\mathrm{2}}} }  & =  \ottsym{(}  \tau_{{\mathrm{1}}}  \ottsym{+}  \tau_{{\mathrm{2}}}  \ottsym{)}  \TREF^{ r_{{\mathrm{1}}}  \ottsym{+}  r_{{\mathrm{2}}} }  & (\rn{Tadd-Ref})
\end{align*}
Viewed another way, type addition describes how to combine two types
for the same value such that the combination soundly incorporates all
information from the two original types.  Critically, the type
addition operation cannot create or destroy ownership and refinement
information, only combine or divide it between types.  Although not
explicit in the rules, by ownership well-formedness, if
the entirety of a reference's ownership is transferred to another type
during a split, all refinements in the remaining type must be
$ \top $.

The additional bits $\land_y  \mathit{y}  =_{ \tau_{{\mathrm{1}}} }  \mathit{x} $ and $\land_x  \mathit{x}  =_{ \tau_{{\mathrm{2}}} }  \mathit{y} $
express equality between $\mathit{x}$ and $\mathit{y}$ as refinements.  We use
the strengthening operation $ \tau  \wedge_{ \mathit{x} }  \varphi $ and typed equality
proposition $ \mathit{x}  =_{ \tau }  \mathit{y} $, defined respectively as:
\begin{align*}
    \set{  \nu  \COL \TINT \mid  \varphi }   \wedge_{ \mathit{y} }  \varphi'  & =  \set{  \nu  \COL \TINT \mid   \varphi  \wedge  \ottsym{[} \, \nu \, \ottsym{/}  \mathit{y}  \ottsym{]} \, \varphi'  }  &
  \ottsym{(}   \mathit{x}  =_{  \set{  \nu  \COL \TINT \mid  \varphi }  }  \mathit{y}   \ottsym{)} & =  \ottsym{(}  \mathit{x} \, \ottsym{=} \, \mathit{y}  \ottsym{)} \\ 
      \tau  \TREF^{ r }   \wedge_{ \mathit{y} }  \varphi'  & =  \tau  \TREF^{ r }  &
    \ottsym{(}   \mathit{x}  =_{  \tau  \TREF^{ r }  }  \mathit{y}   \ottsym{)} & =  \top 
\end{align*}
We do not track equality between references or between the contents of aliased
reference cells as doing so would violate our refinement
well-formedness condition.  These operations are also used in other rules
that can introduce equality.

Rule \rn{T-MkRef} is very similar to \rn{T-Let}, except that $\mathit{x}$
is given a reference type of ownership 1 pointing to $\tau_{{\mathrm{2}}}$, which
is obtained by splitting the type of $\mathit{y}$.  In \rn{T-Deref},
the content type of $\mathit{y}$ is split and distributed to
$\mathit{x}$.  The strengthening is \emph{conditionally} applied depending
on the ownership of the dereferenced pointer, that is, if $r = 0$,
$\tau'$ has to be a maximal type $\top_{\ottmv{i}}$.

% The most noteworthy feature is the
% type addition operator $\tau_{{\mathrm{1}}}  \ottsym{+}  \tau_{{\mathrm{2}}}$ used in \rn{T-Let}, \rn{T-MkRef}, and
% \rn{T-Deref} forms. Intuitively, the type addition operator describes
% how to linearly split a type into two components, dividing information in the original
% type between the two result types.

% The let bindings (\rn{T-Let}, \rn{T-MkRef}, \rn{T-Deref}, and
% \rn{T-LetInt}) introduce new bindings based on the right hand side.
% The rules for \rn{T-Let}, \rn{T-MkRef} and \rn{T-Deref} also \emph{update}
% the type of the variable appearing on the right hand side; as
% information the right-hand side has been linearly transferred to the new binding,
% retaining the original type would be unsound.
% The let rules then type the let body $\ottnt{e}$ in this new environment.
% The typing rule for each form requires the type and result environment of the
% let body to no longer mention the bound variable $\mathit{x}$.

% \AI{\rn{T-Let} already uses $ \tau  \wedge_{ \mathit{y} }  \varphi' $ and it's not for tracking path information.}

% When creating bindings our type system tracks equality between
% integer values.

Our type system also tracks path information; in the \rn{T-If}
rule, we update the refinement on the condition variable within the respective
branches to indicate whether the variable must be zero. By requiring
both branches to produce the same output type environment, we guarantee
that these conflicting refinements are rectified within the
type derivations of the two branches.

The type rule for assert statements has the precondition
$\Gamma  \models  \varphi$ which is defined to be $\models   \sem{ \Gamma }   \implies  \varphi$, i.e.,
the logical formula $ \sem{ \Gamma }   \implies  \varphi$ is valid in the chosen theory.
$ \sem{ \Gamma } $ lifts the refinements on the integer valued variables into a proposition
in the logic used for verification. This denotation
operation is defined as:
\[
\begin{array}{rlcrl}
   \sem{  \bullet  }  &=  \top  & \hspace{1em} &   \sem{  \set{  \nu  \COL \TINT \mid  \varphi }  }_{ \mathit{y} }  & = \ottsym{[}  \mathit{y}  \ottsym{/} \, \nu \, \ottsym{]} \, \varphi \\
   \sem{ \Gamma  \ottsym{,}  \mathit{x}  \ottsym{:}  \tau }  &=  \sem{ \Gamma }   \wedge   \sem{ \tau }_{ \mathit{x} }  &   &   \sem{  \tau'  \TREF^{ r }  }_{ \mathit{y} }  & =  \top  \\
\end{array}
\]
If the formula $ \sem{ \Gamma }   \implies  \varphi$
is valid, then in any context and under any valuation of program variables that satisfy
the refinements in $ \sem{ \Gamma } $,
the predicate $\varphi$ must be true and the
assertion must not fail. This intuition forms the foundation of our
soundness claim (\Cref{sec:soundness}).

\begin{figure}[t]
  \scriptsize
%  \leavevmode
    \infrule[T-Assign]{
    (\text{The shapes of $\tau'$ and $\tau_{{\mathrm{2}}}$ are similar}) \\
     \Theta   \mid   \mathcal{L}   \mid   \Gamma  \ottsym{[}  \mathit{x}  \hookleftarrow  \tau_{{\mathrm{1}}}  \ottsym{]}  \ottsym{[}  \mathit{y}  \hookleftarrow   \ottsym{(}   \tau_{{\mathrm{2}}}  \wedge_{ \mathit{y} }   \mathit{y}  =_{ \tau_{{\mathrm{2}}} }  \mathit{x}    \ottsym{)}  \TREF^{ \ottsym{1} }   \ottsym{]}   \vdash   \ottnt{e}  :  \tau   \produces   \Gamma'  \\
  }{
     \Theta   \mid   \mathcal{L}   \mid   \Gamma  \ottsym{[}  \mathit{x}  \ottsym{:}  \tau_{{\mathrm{1}}}  \ottsym{+}  \tau_{{\mathrm{2}}}  \ottsym{]}  \ottsym{[}  \mathit{y}  \ottsym{:}   \tau'  \TREF^{ \ottsym{1} }   \ottsym{]}   \vdash    \mathit{y}  \WRITE  \mathit{x}  \SEQ  \ottnt{e}   :  \tau   \produces   \Gamma' 
  }
    \vspace*{2ex}
  \infrule[T-Alias]{
    \ottsym{(}    \tau_{{\mathrm{1}}}  \TREF^{ r_{{\mathrm{1}}} }   \ottsym{+}  \tau_{{\mathrm{2}}}  \TREF^{ r_{{\mathrm{2}}} }   \ottsym{)}  \approx  \ottsym{(}    \tau'_{{\mathrm{1}}}  \TREF^{ r'_{{\mathrm{1}}} }   \ottsym{+}  \tau'_{{\mathrm{2}}}  \TREF^{ r'_{{\mathrm{2}}} }   \ottsym{)} \\
     \Theta   \mid   \mathcal{L}   \mid   \Gamma  \ottsym{[}  \mathit{x}  \hookleftarrow   \tau'_{{\mathrm{1}}}  \TREF^{ r'_{{\mathrm{1}}} }   \ottsym{]}  \ottsym{[}  \mathit{y}  \hookleftarrow   \tau'_{{\mathrm{2}}}  \TREF^{ r'_{{\mathrm{2}}} }   \ottsym{]}   \vdash   \ottnt{e}  :  \tau   \produces   \Gamma' 
  }{
     \Theta   \mid   \mathcal{L}   \mid   \Gamma  \ottsym{[}  \mathit{x}  \ottsym{:}   \tau_{{\mathrm{1}}}  \TREF^{ r_{{\mathrm{1}}} }   \ottsym{]}  \ottsym{[}  \mathit{y}  \ottsym{:}   \tau_{{\mathrm{2}}}  \TREF^{ r_{{\mathrm{2}}} }   \ottsym{]}   \vdash    \ALIAS( \mathit{x}  =  \mathit{y} ) \SEQ  \ottnt{e}   :  \tau   \produces   \Gamma' 
  }
    \vspace*{2ex}
  \infrule[T-AliasPtr]{
    \ottsym{(}    \tau_{{\mathrm{1}}}  \TREF^{ r_{{\mathrm{1}}} }   \ottsym{+}  \tau_{{\mathrm{2}}}  \TREF^{ r_{{\mathrm{2}}} }   \ottsym{)}  \approx  \ottsym{(}    \tau'_{{\mathrm{1}}}  \TREF^{ r'_{{\mathrm{1}}} }   \ottsym{+}  \tau'_{{\mathrm{2}}}  \TREF^{ r'_{{\mathrm{2}}} }   \ottsym{)} \\
     \Theta   \mid   \mathcal{L}   \mid   \Gamma  \ottsym{[}  \mathit{x}  \hookleftarrow   \tau'_{{\mathrm{1}}}  \TREF^{ r_{{\mathrm{1}}} }   \ottsym{]}  \ottsym{[}  \mathit{y}  \hookleftarrow   \ottsym{(}   \tau'_{{\mathrm{2}}}  \TREF^{ r'_{{\mathrm{2}}} }   \ottsym{)}  \TREF^{ r }   \ottsym{]}   \vdash   \ottnt{e}  :  \tau   \produces   \Gamma' 
  }{
     \Theta   \mid   \mathcal{L}   \mid   \Gamma  \ottsym{[}  \mathit{x}  \ottsym{:}   \tau_{{\mathrm{1}}}  \TREF^{ r_{{\mathrm{1}}} }   \ottsym{]}  \ottsym{[}  \mathit{y}  \ottsym{:}   \ottsym{(}   \tau_{{\mathrm{2}}}  \TREF^{ r_{{\mathrm{2}}} }   \ottsym{)}  \TREF^{ r }   \ottsym{]}   \vdash    \ALIAS( \mathit{x}  = *  \mathit{y} ) \SEQ  \ottnt{e}   :  \tau   \produces   \Gamma' 
  }
    \vspace*{2ex}
  \infrule[T-Sub]{
    \Gamma  \leq  \Gamma' \andalso
     \Theta   \mid   \mathcal{L}   \mid   \Gamma'   \vdash   \ottnt{e}  :  \tau   \produces   \Gamma''  \andalso
    \Gamma''  \ottsym{,}  \tau  \leq  \Gamma'''  \ottsym{,}  \tau'
  }{
     \Theta   \mid   \mathcal{L}   \mid   \Gamma   \vdash   \ottnt{e}  :  \tau'   \produces   \Gamma''' 
  }
  \vspace*{2ex}
  \begin{center}
    $\tau_{{\mathrm{1}}}  \approx  \tau_{{\mathrm{2}}}$ iff $ \bullet   \vdash  \tau_{{\mathrm{1}}}  \leq  \tau_{{\mathrm{2}}}$ and $ \bullet   \vdash  \tau_{{\mathrm{2}}}  \leq  \tau_{{\mathrm{1}}}$.
  \end{center}
  \caption{Pointer manipulation and subtyping}
  \label{fig:pointer-typing}
\end{figure}

\begin{figure}[t]
%  \leavevmode
%  \bcprulessavespacetrue
  \begin{multicols}{2}
  \scriptsize
  \infrule[S-Int]{
  \Gamma  \models  \varphi_{{\mathrm{1}}}  \implies  \varphi_{{\mathrm{2}}}
  }{
   \Gamma  \vdash   \set{  \nu  \COL \TINT \mid  \varphi_{{\mathrm{1}}} }   \leq   \set{  \nu  \COL \TINT \mid  \varphi_{{\mathrm{2}}} } 
 }
    \vspace*{2ex}
  \infrule[S-Ref]{
     r_{{\mathrm{1}}}   \ge   r_{{\mathrm{2}}} 
    \andalso
    \Gamma  \vdash  \tau_{{\mathrm{1}}}  \leq  \tau_{{\mathrm{2}}}
  }{
    \Gamma  \vdash   \tau_{{\mathrm{1}}}  \TREF^{ r_{{\mathrm{1}}} }   \leq   \tau_{{\mathrm{2}}}  \TREF^{ r_{{\mathrm{2}}} } 
  }
  \infrule[S-TyEnv]{
    \forall \,  \mathit{x}  \in \DOM( \Gamma' )   \ottsym{.}  \Gamma  \vdash  \Gamma  \ottsym{(}  \mathit{x}  \ottsym{)}  \leq  \Gamma'  \ottsym{(}  \mathit{x}  \ottsym{)}
  }{
    \Gamma  \leq  \Gamma'
  }
    \vspace*{2ex}
  \infrule[S-Res]{
    \Gamma  \ottsym{,}  \mathit{x}  \ottsym{:}  \tau  \leq  \Gamma'  \ottsym{,}  \mathit{x}  \ottsym{:}  \tau' \andalso  \mathit{x}  \not\in   \DOM( \Gamma )  
  }{
    \Gamma  \ottsym{,}  \tau  \leq  \Gamma  \ottsym{,}  \tau'
  }
  \end{multicols}
%  \bcprulessavespacefalse
  \caption{Subtyping rules.}
  \label{fig:subtyping}
\end{figure}

\paragraph{Destructive Updates, Aliasing, and Subtyping.}
We now discuss the handling of assignment, aliasing annotations,
and subtyping as described in \Cref{fig:pointer-typing}.
Although apparently unrelated, all three concern
updating the refinements of (potentially) aliased reference cells.

Like the binding forms discussed above, \rn{T-Assign} splits the assigned
value's type into two types via the type addition operator,
and distributes these types between the right hand side of the
assignment and the mutated reference contents.
Refinement information in the fresh
contents \emph{may} be inconsistent with
any previous refinement information; only the shapes must be the same.
In a system with unrestricted aliasing, this
typing rule would be unsound as it would admit writes that
are inconsistent with refinements on aliases of the left hand side.
However, the assignment rule
requires that the updated reference has an ownership of $1$.
By the ownership type invariant, all aliases
with the updated reference have $0$ ownership, and
by ownership well-formedness may only contain the $ \top $ refinement.

\begin{example}
  We can type the program as follows:
\begin{lstlisting}
let x = mkref 5 in       // $\color{comment-green}{ \mathit{x} \COL   \set{  \nu  \COL \TINT \mid  \nu \, \ottsym{=} \, \ottsym{5} }   \TREF^{ \ottsym{1} }  }$
let y = x in             // $\color{comment-green}{\mathit{x}  \ottsym{:}  \top_{{\mathrm{1}}}  \ottsym{,}  \mathit{y}  \ottsym{:}    \set{  \nu  \COL \TINT \mid  \nu \, \ottsym{=} \, \ottsym{5} }   \TREF^{ \ottsym{1} } }$
  y := 4; assert(*y = 4) // $\color{comment-green}{\mathit{x}  \ottsym{:}  \top_{{\mathrm{1}}}  \ottsym{,}  \mathit{y}  \ottsym{:}    \set{  \nu  \COL \TINT \mid  \nu \, \ottsym{=} \, \ottsym{4} }   \TREF^{ \ottsym{1} } }$
\end{lstlisting}
  In this and later examples, we include type annotations within comments. We stress
  that these annotations are for expository purposes only; our tool can infer these types
  automatically with no manual annotations.
\end{example}

As described thus far, the type system is quite strict: if ownership
has been completely transferred from one reference to another, the
refinement information found in the original reference is effectively useless.
Additionally, once
a mutable pointer has been split through an assignment or let expression, there is no
way to recover mutability. The typing rule for
must alias assertions, \rn{T-Alias} and \rn{T-AliasPtr}, overcomes this restriction
by exploiting the must-aliasing information to
``shuffle'' or redistribute ownerships \emph{and refinements} between two
aliased pointers. The typing rule assigns
two fresh types $ \tau'_{{\mathrm{1}}}  \TREF^{ r'_{{\mathrm{1}}} } $ and $ \tau'_{{\mathrm{2}}}  \TREF^{ r'_{{\mathrm{2}}} } $ to the two operand pointers.
The choice of $\tau'_{{\mathrm{1}}}, r'_{{\mathrm{1}}}, \tau'_{{\mathrm{2}}}$, and $r'_{{\mathrm{2}}}$ is left open
provided that the sum of the new types, $\ottsym{(}   \tau'_{{\mathrm{1}}}  \TREF^{ r'_{{\mathrm{1}}} }   \ottsym{)}  \ottsym{+}  \ottsym{(}   \tau'_{{\mathrm{2}}}  \TREF^{ r'_{{\mathrm{2}}} }   \ottsym{)}$ is
equivalent (denoted $ \approx $) to the sum of the original types.
Formally, $ \approx $ is defined as in \Cref{fig:pointer-typing}; it implies
that any refinements in the two types must be logically equivalent and
that ownerships must also be equal. 
%\AI{It's a bit unfortunate that $ \approx $ is mentioned before subtyping is discussed (but the following description seems sufficient to understand the intuition).}
% \AI{Why does $ \approx $ compare two types under the empty type environment?
% Could it use assumptions on other integer variables in $\Gamma$?}
This redistribution is sound precisely because the two references are
assumed to alias; the total ownership for the single memory cell pointed
to by both references cannot be increased by this shuffling. Further,
any refinements that hold for the contents of one reference must necessarily
hold for contents of the other and vice versa.

\begin{example}[Shuffling ownerships and refinements]
  Let $ \varphi_{= n } $ be $\nu \, \ottsym{=} \, n$.
\begin{lstlisting}
let x = mkref 5 in     // $\color{comment-green}{ \mathit{x} \COL   \set{  \nu  \COL \TINT \mid   \varphi_{= \ottsym{5} }  }   \TREF^{ \ottsym{1} }  }$
let y = x in           // $\color{comment-green}{\mathit{x}  \ottsym{:}  \top_{{\mathrm{1}}}  \ottsym{,}  \mathit{y}  \ottsym{:}    \set{  \nu  \COL \TINT \mid   \varphi_{= \ottsym{5} }  }   \TREF^{ \ottsym{1} } }$
  y := 4; alias(x = y) // $\color{comment-green}{\mathit{x}  \ottsym{:}    \set{  \nu  \COL \TINT \mid   \varphi_{= \ottsym{4} }  }   \TREF^{ \ottsym{0}  \ottsym{.}  \ottsym{5} }   \ottsym{,}  \mathit{y}  \ottsym{:}    \set{  \nu  \COL \TINT \mid   \varphi_{= \ottsym{4} }  }   \TREF^{ \ottsym{0}  \ottsym{.}  \ottsym{5} } }$    
\end{lstlisting}
  The final type assignment for $\mathit{x}$ and $\mathit{y}$ is justified by
  \begin{align*}
    & \top_{{\mathrm{1}}}  \ottsym{+}   \set{  \nu  \COL \TINT \mid   \varphi_{= \ottsym{4} }  }   \TREF^{ \ottsym{1} }   \ottsym{=}    \set{  \nu  \COL \TINT \mid    \top   \wedge   \varphi_{= \ottsym{4} }   }   \TREF^{ \ottsym{1} }  \approx \\
    \,\,\,\,&  \set{  \nu  \COL \TINT \mid    \varphi_{= \ottsym{4} }   \wedge   \varphi_{= \ottsym{4} }   }   \TREF^{ \ottsym{1} }   \ottsym{=}     \set{  \nu  \COL \TINT \mid   \varphi_{= \ottsym{4} }  }   \TREF^{ \ottsym{0}  \ottsym{.}  \ottsym{5} }   \ottsym{+}   \set{  \nu  \COL \TINT \mid   \varphi_{= \ottsym{4} }  }   \TREF^{ \ottsym{0}  \ottsym{.}  \ottsym{5} }  .
  \end{align*}
\end{example}

The aliasing rules give fine-grained control over ownership information. This
flexibility allows mutation through two or more aliased references within the same scope.
Provided sufficient aliasing annotations, the type system may shuffle ownerships between
one or more live references, enabling and disabling mutability as required. Although the
reliance on these annotations appears to decrease the practicality of our type system,
we expect these aliasing annotations can be inserted by a conservative must-aliasing
analysis. Further, empirical experience from our prior work \cite{suenaga2009fractional} indicates
that only a small number of annotations are required for larger programs.

\begin{example}[Shuffling Mutability]
  \label{exmp:shuffle-example}
  Let $ \varphi_{= n } $ again be $\nu \, \ottsym{=} \, n$.
  The following program uses two live, aliased references to mutate the same memory location:
\begin{lstlisting}
let x = mkref 0 in
let y = x in            // $\color{comment-green}{\mathit{x}  \ottsym{:}    \set{  \nu  \COL \TINT \mid   \varphi_{= \ottsym{0} }  }   \TREF^{ \ottsym{1} }   \ottsym{,}  \mathit{y}  \ottsym{:}  \top_{{\mathrm{1}}}}$
  x := 1; alias(x = y); // $\color{comment-green}{\mathit{x}  \ottsym{:}  \top_{{\mathrm{1}}}  \ottsym{,}  \mathit{y}  \ottsym{:}    \set{  \nu  \COL \TINT \mid   \varphi_{= \ottsym{1} }  }   \TREF^{ \ottsym{1} } }$
  y := 2; alias(x = y); // $\color{comment-green}{\mathit{x}  \ottsym{:}    \set{  \nu  \COL \TINT \mid   \varphi_{= \ottsym{2} }  }   \TREF^{ \ottsym{0}  \ottsym{.}  \ottsym{5} }   \ottsym{,}  \mathit{y}  \ottsym{:}    \set{  \nu  \COL \TINT \mid   \varphi_{= \ottsym{2} }  }   \TREF^{ \ottsym{0}  \ottsym{.}  \ottsym{5} } }$
  assert(*x = 2)
\end{lstlisting}
  % The types shown in the comments give the type environment under
  % which the first statement on the line is typed.
  After the first aliasing
  statement the type system shuffles the (exclusive) mutability between $\mathit{x}$
  and $\mathit{y}$ to enable the write to $\mathit{y}$. After the second aliasing statement
  the ownership in $\mathit{y}$ is split with $\mathit{x}$; note that
  transferring all ownership from $\mathit{y}$ to $\mathit{x}$ would also yield a
  valid typing.
\end{example}

Finally, we describe the subtyping rule. The rules for subtyping types
and environments are shown in \Cref{fig:subtyping}. For integer types,
the rules require the refinement of a supertype is a logical consequence of
the subtype's refinement conjoined with the lifting of $\Gamma$.
The subtype rule for references is \emph{covariant} in the type
of reference contents. It is widely known that in a language with unrestricted aliasing
and mutable references such a rule is unsound: after a write into the coerced
pointer, reads from an alias may yield a value disallowed by the alias' type
\cite{pierce2002types}. However, as in
the assign case, ownership types prevent unsoundness; a write to the
coerced pointer requires the pointer to have ownership 1, which guarantees
any aliased pointers have the maximal type and provide no information about their contents
beyond simple types.\looseness=-1

\begin{figure}[t]
  \leavevmode
    \infrule[T-Call]{
    \Theta  \ottsym{(}  \mathit{f}  \ottsym{)}  \ottsym{=}   \forall  \lambda .\tuple{ \mathit{x_{{\mathrm{1}}}} \COL \tau_{{\mathrm{1}}} ,\dots, \mathit{x_{\ottmv{n}}} \COL \tau_{\ottmv{n}} }\ra\tuple{ \mathit{x_{{\mathrm{1}}}} \COL \tau'_{{\mathrm{1}}} ,\dots, \mathit{x_{\ottmv{n}}} \COL \tau'_{\ottmv{n}}  \mid  \tau }  \\
    \sigma_{\alpha}  \ottsym{=}  \ottsym{[}  \ell  \ottsym{:}  \mathcal{L}  \ottsym{/}  \lambda  \ottsym{]} \andalso \sigma_{x}  \ottsym{=}    [  \mathit{y_{{\mathrm{1}}}}  /  \mathit{x_{{\mathrm{1}}}}  ]  \cdots  [  \mathit{y_{\ottmv{n}}}  /  \mathit{x_{\ottmv{n}}}  ]   \\
     \Theta   \mid   \mathcal{L}   \mid   \Gamma  \ottsym{[}  \mathit{y_{\ottmv{i}}}  \hookleftarrow  \sigma_{\alpha} \, \sigma_{x} \, \tau'_{\ottmv{i}}  \ottsym{]}  \ottsym{,}  \mathit{x}  \ottsym{:}  \sigma_{\alpha} \, \sigma_{x} \, \tau   \vdash   \ottnt{e}  :  \tau'   \produces   \Gamma'  \andalso
     \mathit{x}  \not\in   \DOM( \Gamma' )  
  }{
     \Theta   \mid   \mathcal{L}   \mid   \Gamma  \ottsym{[}  \mathit{y_{\ottmv{i}}}  \ottsym{:}  \sigma_{\alpha} \, \sigma_{x} \, \tau_{\ottmv{i}}  \ottsym{]}   \vdash    \LET  \mathit{x}  =   \mathit{f} ^ \ell (  \mathit{y_{{\mathrm{1}}}} ,\ldots, \mathit{y_{\ottmv{n}}}  )   \IN  \ottnt{e}   :  \tau'   \produces   \Gamma' 
  }
  \infrule[T-FunDef]{
    \Theta  \ottsym{(}  \mathit{f}  \ottsym{)}  \ottsym{=}   \forall  \lambda .\tuple{ \mathit{x_{{\mathrm{1}}}} \COL \tau_{{\mathrm{1}}} ,\dots, \mathit{x_{\ottmv{n}}} \COL \tau_{\ottmv{n}} }\ra\tuple{ \mathit{x_{{\mathrm{1}}}} \COL \tau'_{{\mathrm{1}}} ,\dots, \mathit{x_{\ottmv{n}}} \COL \tau'_{\ottmv{n}}  \mid  \tau }  \\
     \Theta   \mid   \lambda   \mid    \mathit{x_{{\mathrm{1}}}} \COL \tau_{{\mathrm{1}}} ,\ldots, \mathit{x_{\ottmv{n}}} \COL \tau_{\ottmv{n}}    \vdash   \ottnt{e}  :  \tau   \produces    \mathit{x_{{\mathrm{1}}}} \COL \tau'_{{\mathrm{1}}} ,\ldots, \mathit{x_{\ottmv{n}}} \COL \tau'_{\ottmv{n}}  
  }{
    \Theta  \vdash  \mathit{f}  \mapsto  \ottsym{(}  \mathit{x_{{\mathrm{1}}}}  \ottsym{,} \, .. \, \ottsym{,}  \mathit{x_{\ottmv{n}}}  \ottsym{)}  \ottnt{e}
  }
  \bcprulessavespacetrue
  \infrule[T-Funs]{
    \forall  \mathit{f}  \mapsto  \ottsym{(}  \mathit{x_{{\mathrm{1}}}}  \ottsym{,} \, .. \, \ottsym{,}  \mathit{x_{\ottmv{n}}}  \ottsym{)}  \ottnt{e}  \in  \ottnt{D} .\Theta  \vdash  \mathit{f}  \mapsto  \ottsym{(}  \mathit{x_{{\mathrm{1}}}}  \ottsym{,} \, .. \, \ottsym{,}  \mathit{x_{\ottmv{n}}}  \ottsym{)}  \ottnt{e} \\  \DOM( \ottnt{D} )   \ottsym{=}   \DOM( \Theta ) 
  }{
    \Theta  \vdash  \ottnt{D}
  }
  \hfil
  \infrule[T-Prog]{
    \Theta  \vdash  \ottnt{D} \andalso  \vdash _{\wf}  \Theta  \\
     \Theta   \mid    \epsilon    \mid    \bullet    \vdash   \ottnt{e}  :  \tau   \produces   \Gamma 
  }{
    \vdash   \tuple{ \ottnt{D} ,  \ottnt{e} } 
  }
  \bcprulessavespacefalse
\caption{Program typing rules}
\label{fig:progTyping}
\end{figure}

\subsection{Interprocedural Fragment and Context-Sensitivity}
\label{sec:cs}
We now turn to a discussion of the interprocedural fragment of our
language, and how our type system propagates context information. The remaining
typing rules for our language are shown in \Cref{fig:progTyping}.
These rules concern the typing of function calls, function bodies, and
entire programs.

We first explain the \rn{T-Call} rule. The rule uses two substitution
maps. $\sigma_{x}$ translates between the parameter names used in the
function type and actual argument names at the call-site. $\sigma_{\alpha}$
instantiates all occurrences of $\lambda$ in the callee type with
$\ell  \ottsym{:}  \mathcal{L}$, where $\ell$ is the label of the call-site and $\mathcal{L}$
the typing context of the call.  The types of the arguments $\mathit{y_{\ottmv{i}}}$'s
are required to match the parameter types (post substitution). The
body of the let binding is then checked with the argument types
updated to reflect the changes in the function call (again, post
substitution). This update is well-defined because we require all
function arguments be distinct as described in \Cref{sec:language}.
Intuitively, the substitution $\sigma_{\alpha}$ represents incrementally
refining the behavior of the callee function with partial context
information.  If $\mathcal{L}$ is itself a context variable $\lambda'$, this
substitution effectively transforms any context prefix queries over
$\lambda$ in the argument/return/output types into a queries over
$\ell  \ottsym{:}  \lambda'$.  In other words, while the exact concrete execution context
of the callee is unknown, the context must at least begin with $\ell$
which can potentially rule out certain behaviors.

Rule \rn{T-FunDef} type checks a function definition
$\mathit{f}  \mapsto  \ottsym{(}  \mathit{x_{{\mathrm{1}}}}  \ottsym{,} \, .. \, \ottsym{,}  \mathit{x_{\ottmv{n}}}  \ottsym{)}  \ottnt{e}$ against the function type given in $\Theta$.
As a convenience we assume that the parameter
names in the function type match the formal parameters in the function
definition. The rule checks that under an initial environment given
by the argument types the function body produces a value of the
return type and transforms the arguments according to the output types.
As mentioned above, functions may be executed under many different contexts,
so type checking the function body is performed under the context
variable $\lambda$ that occurs in the function type.

Finally, the rule for typing programs (\rn{T-Prog}) checks that
all function definitions are well typed under a well-formed
function type environment, and that the entry point $\ottnt{e}$
is well typed in an empty type environment and the typing context
$ \epsilon $, i.e., the initial context.

\begin{example}[1-CFA]
  \label{exmp:1cfa}
  Recall the program in \Cref{fig:running-example} in \Cref{sec:intro}; assume
  the function calls are labeled as follows:
\begin{lstlisting}
p := get$^{\ell1}$(p) + 1;
// ...
q := get$^{\ell2}$(q) + 1;
\end{lstlisting}
  Taking $\tau_{\ottmv{p}}$ to be the type shown in \Cref{exmp:cs-type-example}:
  \[
     \set{  \nu  \COL \TINT \mid   \ottsym{(}    \ell_{{\mathrm{1}}}     \preceq    \lambda   \implies  \nu \, \ottsym{=} \, \ottsym{3}  \ottsym{)}  \wedge  \ottsym{(}    \ell_{{\mathrm{2}}}     \preceq    \lambda   \implies  \nu \, \ottsym{=} \, \ottsym{5}  \ottsym{)}  } 
  \]
  we can give \lstinline{get} the type $ \forall  \lambda .\tuple{ \mathit{z}  \ottsym{:}   \tau_{\ottmv{p}}  \TREF^{ \ottsym{1} }  }\ra\tuple{ \mathit{z}  \ottsym{:}   \tau_{\ottmv{p}}  \TREF^{ \ottsym{1} }  \mid \tau_{\ottmv{p}} } $.
\end{example}
\begin{example}[2-CFA]
  To see how context information propagates across multiple calls, consider
  the following change to the code considered in \Cref{exmp:1cfa}:
  \begin{lstlisting}
    get_real(z) { *z }
    get(z) { get_real$^{\ell_{{\mathrm{3}}}}$(z) }
  \end{lstlisting}
  The type of \imp{get} remains as in \Cref{exmp:1cfa}, and taking $\tau$
  to be \[
     \set{  \nu  \COL \TINT \mid   \ottsym{(}    \ell_{{\mathrm{3}}} \, \ell_{{\mathrm{1}}}     \preceq    \lambda'   \implies  \nu \, \ottsym{=} \, \ottsym{3}  \ottsym{)}  \wedge  \ottsym{(}    \ell_{{\mathrm{3}}} \, \ell_{{\mathrm{2}}}     \preceq    \lambda'   \implies  \nu \, \ottsym{=} \, \ottsym{5}  \ottsym{)}  } 
  \]
  the type of \imp{get_real} is: $ \forall  \lambda' .\tuple{ \mathit{z}  \ottsym{:}   \tau  \TREF^{ \ottsym{1} }  }\ra\tuple{ \mathit{z}  \ottsym{:}   \tau  \TREF^{ \ottsym{1} }  \mid \tau } $.

  We focus on the typing of the call to \imp{get_real} in \imp{get}; it
  is typed in context $\lambda$ and a type environment where
  \imp{p} is given type $\tau_{\ottmv{p}}$ from \Cref{exmp:1cfa}.

  Applying the substitution $\ottsym{[}  \ell_{{\mathrm{3}}}  \ottsym{:}  \lambda  \ottsym{/}  \lambda'  \ottsym{]}$ to the argument
  type of \imp{get_real} yields:
  \begin{align*}
    &   \set{  \nu  \COL \TINT \mid   \ottsym{(}    \ell_{{\mathrm{3}}} \, \ell_{{\mathrm{1}}}     \preceq     \ell_{{\mathrm{3}}}  :  \lambda    \implies  \nu \, \ottsym{=} \, \ottsym{3}  \ottsym{)}  \wedge  \ottsym{(}    \ell_{{\mathrm{3}}} \, \ell_{{\mathrm{2}}}     \preceq     \ell_{{\mathrm{3}}}  :  \lambda    \implies  \nu \, \ottsym{=} \, \ottsym{5}  \ottsym{)}  }   \TREF^{ \ottsym{1} }  \approx  \\
    & \,\,\,\,\,   \set{  \nu  \COL \TINT \mid   \ottsym{(}    \ell_{{\mathrm{1}}}     \preceq    \lambda   \implies  \nu \, \ottsym{=} \, \ottsym{3}  \ottsym{)}  \wedge  \ottsym{(}    \ell_{{\mathrm{2}}}     \preceq    \lambda   \implies  \nu \, \ottsym{=} \, \ottsym{5}  \ottsym{)}  }   \TREF^{ \ottsym{1} } 
  \end{align*}
  which is exactly the type of \imp{p}.
  A similar derivation applies to
  the return type of \imp{get_real} and thus \imp{get}.
\end{example}

\subsection{Soundness}
\label{sec:soundness}
We have proven that any program that type checks according to
the rules above will never experience an assertion failure.
We formalize this claim with the following soundness theorem.

\begin{theorem}[Soundness]
  \label{thm:soundness}
  If  $\vdash   \tuple{ \ottnt{D} ,  \ottnt{e} } $, then
  $  \tuple{  \emptyset  ,   \emptyset  ,   \cdot  ,  \ottnt{e} }      \not \longrightarrow^*  _{ \ottnt{D} }     \mathbf{AssertFail}  $.
  
  Further, any well-typed program either diverges, halts in the configuration $ \mathbf{AliasFail} $, or
  halts in a configuration $ \tuple{ \ottnt{H} ,  \ottnt{R} ,   \cdot  ,  \mathit{x} } $ for some $\ottnt{H}, \ottnt{R}$ and $\mathit{x}$, i.e.,
  evaluation does not get stuck.
\end{theorem}
\begin{proof}[Sketch]
  By standard progress and preservation lemmas; 
  the full proof has been omitted for space reasons and can be found
  in the \appref{accompanying appendix}{full version \cite{toman2020consort}}.\looseness=-1

  % We define a typing relation for runtime configurations; well-typed
  % configurations satisfy the following invariants:
  % \begin{enumerate}
  % \item The value at heap locations and program variables satisfy the refinements given in the program typing judgment, and
  % \item The ownership given to every memory cell never exceeds 1.
  % \end{enumerate}
  % We then prove a standard preservation lemma, showing that
  % well-typedness is preserved by our step relation.  By defining the
  % $ \mathbf{AssertFail} $ configuration as ill-typed, we have the first result.

  % The second result follows from preservation and standard progress lemma.
\end{proof}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:

%  LocalWords:  Suenaga Kobayashi deallocation ownerships CFA MkRef
%  LocalWords:  Formedness formedness supertype subtype's covariant
%  LocalWords:  Deref LetInt dereferenced typedness
